import random
import bisect
import numpy


from igraph import *   

#Given a density distribution, RDDmodel returns a random graph with the given density distribution as generated by the random density distribution model.

def RDDmodel(sig):    
    # take a list of numbers
    G = Graph(0,[],True)

    di = len(sig)-1
    starti = 0
    while di > 0:
        # add ni vertices
        G.add_vertices(range(starti,starti+sig[di]))

        # add edges between new vertices and to old vertices
        print(sig[di],di)
        for j in range(sig[di]):
            # for each new vertex
            dadded = 0
            while dadded < di:
                l = random.randint(0,starti+sig[di]-1)
                G.add_edge(l, starti+j)
                dadded = dadded + 1
        starti = starti+sig[di]
        di = di-1
    G.add_vertices(sig[0])
                
    return PathReversal(G)


#Given a density distribution and a probability. HSWmodel returns a random graph with the given density distribution as generated by the hierarchical small worlds model.

def HSWmodel(sig, p):
    G = Graph(0,[],True)

    di = len(sig)-1
    starti = 0
    # create top box
    G.add_vertices(sig[di])

    for j in range(sig[di]):
        G.vs[j]["box"] = di
        # for each new vertex, add di edges to immediate neighbors or arb
        for i in range(1,di+1):
            if random.random() > p:
                G.add_edge(starti+((j+i) % sig[di]), starti+j)
        
    # add missing edges:
    for j in range(sig[di]):
        while G.degree(starti+j,IN) < di:
            l = random.randint(0,sig[di]-1)

            G.add_edge(l, j)
        

    starti = starti+sig[di]
    di = di-1
    edges = []
    while di > 0:
        print(sig[di],di)

        # add ni vertices
        G.add_vertices(sig[di])

        # add edges between new vertices
        for j in range(sig[di]):
		G.vs[starti+j]["box"] = di
		# for each new vertex, add remaining edges to immediate neighbors whp
		for i in range(1,di+1):
			if random.random() > p:
				G.add_edge(starti+((j+i) % sig[di]), starti+j)

        # add missing edges:
        for j in range(sig[di]):
            while G.degree(starti+j,IN) < di:
                l = random.randint(0,sig[di]-1)
                G.add_edge(l, starti+j)
                
        starti = starti+sig[di]
        di = di-1

    G.add_vertices(sig[0])
    for j in range(sig[di]):
	    G.vs[starti+j]["box"] = di
    return G
